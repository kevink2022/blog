<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Learning on Kevin Kelly</title>
    <link>http://localhost:1313/blog/tags/learning/</link>
    <description>Recent content in Learning on Kevin Kelly</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>kevink2019@gmail.com (Kevin Kelly)</managingEditor>
    <webMaster>kevink2019@gmail.com (Kevin Kelly)</webMaster>
    <copyright>Kevin Kelly (CC BY 4.0)</copyright>
    <lastBuildDate>Thu, 11 Jul 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/blog/tags/learning/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Make your own contract.</title>
      <link>http://localhost:1313/blog/blog/make_your_own_contract/</link>
      <pubDate>Thu, 11 Jul 2024 00:00:00 +0000</pubDate><author>kevink2019@gmail.com (Kevin Kelly)</author>
      <guid>http://localhost:1313/blog/blog/make_your_own_contract/</guid>
      <description>I want to talk about a specific problem I just worked on, and how two logically identical solutions can make a huge difference in taming the complexity of software.&#xA;Boiling it down to the essentials, we have a map, or dictionary, of ID objects to Tag objects, called tagMap. This map is built with the following three operations:&#xA;add(id: ID, tags: Set&amp;lt;Tag&amp;gt;) add a new ID with its associated Tag objects (ID is guaranteed to not exist in tagMap) update(id: ID, tags: Set&amp;lt;Tag&amp;gt;) update the tags for an ID (ID is guaranteed to exist in tagMap) delete(id: ID) delete the ID from the map (ID is guaranteed to exist in tagMap) How would you keep track of a set of all of the tags in use for use elsewhere in the program?</description>
      <content:encoded><![CDATA[<p>I want to talk about a specific problem I just worked on, and how two logically identical solutions can make a huge difference in taming the complexity of software.</p>
<p>Boiling it down to the essentials, we have a map, or dictionary, of <code>ID</code> objects to <code>Tag</code> objects, called <code>tagMap</code>. This map is built with the following three operations:</p>
<ul>
<li><code>add(id: ID, tags: Set&lt;Tag&gt;)</code>
<ul>
<li>add a new <code>ID</code> with its associated <code>Tag</code> objects  (<code>ID</code> is guaranteed to <em>not exist</em> in <code>tagMap</code>)</li>
</ul>
</li>
<li><code>update(id: ID, tags: Set&lt;Tag&gt;)</code>
<ul>
<li>update the tags for an <code>ID</code> (<code>ID</code> is guaranteed to exist in <code>tagMap</code>)</li>
</ul>
</li>
<li><code>delete(id: ID)</code>
<ul>
<li>delete the <code>ID</code> from the map (<code>ID</code> is guaranteed to exist in <code>tagMap</code>)</li>
</ul>
</li>
</ul>
<p>How would you keep track of a <em>set</em> of all of the tags in use <em>for use elsewhere in the program?</em></p>
<p>If you really want to leetcode this, here&rsquo;s the code so far:</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TagManager</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span>	<span style="color:#66d9ef">var</span> tagMap: [ID: Set&lt;Tag&gt;] = [:]
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span>	<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>(id: ID, tags: Set&lt;Tag&gt;) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span>		tagMap[id] = tags
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span>	}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span>	<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">delete</span>(id: ID) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span>		tagMap[id] = <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span>	}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span><span>	
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span><span>	<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">update</span>(id: ID, tags: Set&lt;Tag&gt;) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span><span>		<span style="color:#66d9ef">let</span> oldTags = tagMap[id]
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span><span>		delete(id: id, tags: oldTags)
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span><span>		add(id: id, tags: tags)
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span><span>	}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18</span><span>}</span></span></code></pre></div><hr>
<p>I landed on using a new dictionary, mapping a <code>Tag</code> to the number of times that tag occurs in the <code>tagMap</code>. With that, we can simply add each tag to the dictionary on an add/update, and remove each tag on an update/remove.</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TagManager</span> {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span>	<span style="color:#66d9ef">var</span> tagMap: [ID: Set&lt;Tag&gt;] = [:]
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span>	<span style="color:#66d9ef">var</span> tagCounts: [Tag: Int] = [:] <span style="color:#75715e">// NEW</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span>					
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span>	<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>(id: ID, tags: Set&lt;Tag&gt;) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span>		tagMap[id] = tags
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span>		<span style="color:#75715e">// NEW</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span>		<span style="color:#66d9ef">for</span> tag <span style="color:#66d9ef">in</span> tags {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span>			<span style="color:#66d9ef">let</span> count = tagCounts[tag] ?? <span style="color:#ae81ff">0</span> 
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span><span>			tagCounts[tag] = count <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span><span>		}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span><span>	}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span><span>	<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">delete</span>(id: ID) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span><span>		<span style="color:#66d9ef">let</span> tagsToDelete = tagMap[id] ?? [] <span style="color:#75715e">// NEW</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18</span><span>		tagMap[id] = <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20</span><span>		<span style="color:#75715e">// NEW</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21</span><span>		<span style="color:#66d9ef">for</span> tag <span style="color:#66d9ef">in</span> tagsToDelete {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22</span><span>			<span style="color:#66d9ef">let</span> count = tagCounts[tag] ?? <span style="color:#ae81ff">0</span> 
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24</span><span>			<span style="color:#66d9ef">if</span> count == <span style="color:#ae81ff">1</span> { 
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25</span><span>				tagCounts[tag] = <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26</span><span>			} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27</span><span>				tagCounts[tag] = count <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28</span><span>			}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29</span><span>		}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30</span><span>	}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31</span><span>}</span></span></code></pre></div><p>This <em>works</em>, but look back at what I emphasized in the question earlier: a set for use elsewhere in the program. Our conceptual model of <code>tagsInUse</code> is a set, but we have a dictionary. We can easily solve this in the public API:</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#66d9ef">private</span>	<span style="color:#66d9ef">var</span> tagCounts: [Tag: Int] = [:]
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">var</span> tagsInUse: Set&lt;Tag&gt; { Set(tagCounts.keys) }</span></span></code></pre></div><p>But why settle for fixing this in the public API? Bringing that concise conceptual model down into our own logic will help us write code thats more intentional and easier to understand. I think a good way to demonstrate the communication weakness this current solution presents is through the telephone game - explaining your logic to a colleague over the phone.</p>
<blockquote>
<p>We keep track of the <em>set</em> <code>tagsInUse</code> using a <em>dictionary</em> called <code>tagCounts</code>, where we keep count of the number of instances of that tag. So when we add a tag to the <em>set</em> <code>tagsInUse</code> for the first time, we add it to the <em>dictionary</em> <code>tagCounts</code> with a count of one. If we add it again, we update it count to 2. Now, if we remove it once, we just drop it count to 1, its still in our <em>set</em> <code>tagsInUse</code>, which is derived from the keys of <code>tagCounts</code>. Only when we remove it again, do we actually remove it from the <em>set</em> by removing the key from the <em>dictionary,</em> since the count reached zero.</p>
</blockquote>
<p>This makes sense, and can probably be followed, but again I emphasized the use of <em>set</em> and <em>dictionary</em> to point out the weird tension here between the conceptual model and the implementation. We can&rsquo;t use a set, because that data structure won&rsquo;t actually keep track of the information the way we need. But we&rsquo;re sort of <em>breaking the semantic contract</em> of a dictionary as well. We don&rsquo;t actually care about the specific count, we just care if the tag is one of the keys.</p>
<p>I think this idea, of a <em>using a dictionary</em> to <em>track a set</em> over multiple inserts and removals, is a distinct, generalizable conceptual model, separate from a regular set or a dictionary. So, lets create a new semantic contract: a <strong>Counted Set.</strong></p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CountedSet</span>&lt;Element&gt; {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span>	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> storage: [Element: Int]
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span>	<span style="color:#66d9ef">mutating</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">_</span> element: Element) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> count = storage[element] {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span>            storage[element] = count <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span>            storage[element] = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span>        }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span>    }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span><span>	<span style="color:#66d9ef">mutating</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">remove</span>(<span style="color:#66d9ef">_</span> element: Element) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> count = storage[element] {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span><span>            <span style="color:#66d9ef">if</span> count <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span> { storage[element] = <span style="color:#66d9ef">nil</span> }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span><span>            <span style="color:#66d9ef">else</span> { storage[element] = count <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span><span>        }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span><span>    }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19</span><span>	<span style="color:#75715e">/* Insert/Remove contentsOf Sets/Arrays */</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20</span><span>}</span></span></code></pre></div><p>And our code becomes trivially simple:</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TagManager</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span>	<span style="color:#66d9ef">var</span> tagMap: [ID: Set&lt;Tag&gt;] = [:]
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span>	<span style="color:#66d9ef">var</span> tagsInUse: CountedSet&lt;Tag&gt; 
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span>	<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>(id: ID, tags: Set&lt;Tag&gt;) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span>		tagMap[id] = tags
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span>		tagsInUse.insert(contentsOf: tags)
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span>	}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span>	<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">delete</span>(id: ID) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span>		tagMap[id] = <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span><span>		tagsInUse.remove(contentsOf: tags)
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span><span>	}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span><span>}</span></span></code></pre></div><p>And so does our explanation:</p>
<blockquote>
<p>We keep track of the <em>set</em> <code>tagsInUse</code> using a counted <em>set</em>.</p>
</blockquote>
<p>This new explanation relies on the readers knowing what a counted set is. But the counted set can be easily explained and understood outside of the context of the problem. And with that understanding, the explanation of the logic becomes explicit <em>in</em> the code through the semantics of the counted set and its documentation, while the original implementation (which is logically the exact same) has no explanation at all, requiring the inferior solution of comments.</p>
<p>On top of that, reifying the conceptual model of the counted set chunks it into a single idea into our heads, freeing up room in our limited working memory for the rest of the problem. In the original solution, the sets of <code>Tag</code> and the <code>tagMap</code> dictionary of <code>ID</code> to <code>Set&lt;Tag&gt;</code>, which don&rsquo;t break the semantic contracts of the their data structures, are easily thought of as single ideas. They don&rsquo;t clog our working memory with extra details. But the <code>tagCount</code> dictionary isn&rsquo;t just a dictionary, it&rsquo;s a dictionary with extra rules, where a key&rsquo;s values aren&rsquo;t changed arbitrarily. An implicit contract, that needs to be implemented correctly in multiple places. Multiple things to keep track of in our heads.</p>
<p>But once we go ahead and make the contract explicit, putting a label on it, our brains can chunk it and treat it just like another set or dictionary. Now, alongside our <code>tagMap</code>, our <code>tagsInUse</code> is just another simple data structure we use, with an explicit contract and conceptual model, cleanly labeled in our working memory.</p>
<p>I think this is such an essential concept, because we often don&rsquo;t even get the privilege of the telephone game. Our code may be read by someone else, in a different timezone, years after we wrote it. So instead of getting to explain to them the conceptual model we had when writing it, all of that intentionality has to be documented in the code.</p>
<p>Computer Science is a mathematical discipline: we&rsquo;re looking for a <em>correct</em> solutions. In my opinion, Software Engineering is much more of a <em>communication</em> discipline: there may be many correct solutions, but its vital to consider how your solution communicates your conceptual model to future maintainers (including yourself) in order to keep the software complexity monster in check.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Do you understand it, or do you just know it?</title>
      <link>http://localhost:1313/blog/blog/knowing_vs_understanding/</link>
      <pubDate>Mon, 13 May 2024 00:00:00 +0000</pubDate><author>kevink2019@gmail.com (Kevin Kelly)</author>
      <guid>http://localhost:1313/blog/blog/knowing_vs_understanding/</guid>
      <description>This first half of this post is a personal story, adding context to how I came to these conclusions at this point in my life. If you want to jump straight to the difference between knowing and understanding, feel free to skip to what it means to understand.&#xA;We should really read more. I was hanging out with some US Air Force officers, at the invite of a friend who himself is an officer.</description>
      <content:encoded><![CDATA[<p>This first half of this post is a personal story, adding context to how I came to these conclusions at this point in my life. If you want to jump straight to the difference between knowing and understanding, feel free to skip to <a href="#what-it-means-to-understand">what it means to understand.</a></p>
<hr>
<h3 id="we-should-really-read-more">We should really read more.</h3>
<p>I was hanging out with some US Air Force officers, at the invite of a friend who himself is an officer. We got on the topic about reading, specifically how we all really should read more. Someone made a comment about how the most successful, high ranking officers they knew always seemed to be reading something, and always had a whole bookshelf full of books in their office.</p>
<p>The cynical side of me wanted to say something about how reading all those books is impossible unless you have something driving you more then the vain, ephemeral idea of &lsquo;success.&rsquo; For most people, at least.</p>
<p>At the time, I assumed that drive had to come from some innate interest or curiosity, that had to be there before you ever started learning about the topic. That most of these high ranking officers, whether they knew it or not, were in some way interested in how organizations work and how to effectively lead. Combine that with them being put into a position to lead and/or picking up their first book on the topic, and their pursuit of knowledge began.</p>
<p>I now understand that this line of thinking was an artifact of the &lsquo;fixed mindset,&rsquo; (basically the opposite of a &lsquo;growth mindset&rsquo;) that I had just recently recognized was slowing me down. Because I had no issue reading, I&rsquo;ve read entire <em>Song of Ice and Fire</em> books in less than 2 weeks. But it was a deep interest in the story, the world, and pre-modern societies in general that fueled my rabid reading. Without that underlying interest being awoken, there&rsquo;s no way I would read hundreds of pages or blow through hours of content on something as boring as how to run an organization.</p>
<hr>
<h3 id="a-life-of-knowing">A life of knowing</h3>
<p>I was always very, very successful in school with very little effort. I was consistently called the smartest person in the room. While I&rsquo;m sure people understood that this may create a massive ego problem (and it very much did), what I&rsquo;m sure what they didn&rsquo;t understand was how they were setting me up to be very conservative in my future endeavors.</p>
<p>This phenomenon is described in detail in Carol Dweck&rsquo;s writings on <a href="https://ctl.stanford.edu/sites/g/files/sbiybj17446/files/media/file/growth_mindset_handout.pdf">growth mindset</a>, but to sum it up, when people are praised, believe it or not, it makes them happy. Unsurprisingly, this then drives them towards behavior directed at continuing to receiving that praise.</p>
<p>The catch is, when people are praised for their fixed, <em>intrinsic</em> traits, such as how smart or talented they are, that doesn&rsquo;t encourage them to seek harder challenges that are outside of their comfort zone. In fact, the opposite usually happens - they seek easier challenges. To them, failure makes them question their own identity and the self-worth that they based on that identity (I can vouch for that). Now, when you praise people for their <em>extrinsic</em> trait of <em>effort</em>, something they can directly control, well you can imagine how their behavior might differ.</p>
<p>I took pride in my ability to not just cram, but often gave people awful advice to not spend so much time trying to <em>understand</em>. You really didn&rsquo;t need to understand why, for example, the derivative of <code>cos(x)</code> was <code>-sin(x)</code>. That was just another tool in your toolbox that you needed to <em>know.</em></p>
<p>And so I continued through school and graduated college with honors, but always struggled to accomplish anything outside of my coursework. However, I always found excuses for this lack of production, cause I was just too smart to fail. I had just failed to manage my time outside my coursework. But then I graduated 6 months early, and took those 6 months off to finally do interesting something with my life.</p>
<hr>
<h3 id="beginning-to-understand">Beginning to understand</h3>
<p>My main goal at the end of those 6 months was to have an app on the iOS App Store. Not a super lofty goal, but I wanted a real, useful app, not just some gimmick. I had taken the Swift UI class at Penn State, so felt that I knew everything I needed to <em>know</em> to clean up my rushed final project, which was <a href="/blog/tags/boomic/">Boomic Music</a>. But that was such a mess, as I has rushed to get as many features as possible done during class, didn&rsquo;t spend any time on architecture, and skipped a lot of the hard problems. So I quickly pivoted to something easier: a workout app. Then I pivoted about 3-4 more times over the next few months.</p>
<p>I can&rsquo;t really pull any lessons out of those 6 months, other than to just focus on one project at a time, because I was just making the same mistakes over and over again. The real problem was that, of course, the 3 credit class I took was nowhere near enough to build an app on the scale I wanted. And I was <em>really</em> impatient. When I ran into something I didn&rsquo;t know, I wanted to know it as soon as possible and move on. Just like when I was doing my homework or studying for a test.</p>
<p>Fast forward to the end of 2023, a year since I graduated. I was six months into a very unfulfilling implementation consultant role, and had nothing to put on my resume to give me hope about that changing any time soon. I made a few commitments to myself (such as committing to a growth mindset), and after stumbling upon an article on <a href="/blog/learning/ten_things_about_learning/">10 Things Software Developers Should Learn about Learning</a>, I committed to two more things:</p>
<ul>
<li>Actually learning how to architect an app by taking my time and reading as much source code/learning materials as possible</li>
<li>Focus 100% of my creative energy on finally building Boomic. No more pivoting.</li>
</ul>
<p>The single text that kick-started my understanding of mobile architectures was Jacob Bartlett&rsquo;s blog post on <a href="https://jacobbartlett.substack.com/p/modular-architecture-for-apps">Modular Architecture for Apps</a>. Following the layered architecture, development was going much better then it had in the past, and I had some newfound confidence. Until I had to throw out 3 weeks of work due to some poor assumptions I made. The familiar fears of of failure and wasted time began to well up inside me.</p>
<p>But this time, with a growth mindset, I really reflected on what went wrong, and learned from my mistakes. Oh, and I discovered Rich Hickey.</p>
<p>Over the next few weeks, I went ahead an consumed almost every talk that man has given, and most the keynotes twice. I consistently had better ideas of how to compose my app, both during the talks and in the days after. These presentations, mostly from over a decade ago before the Swift language existed, without a line of source code, gave me so much insight and confidence to write Swift code. It gave me a deeper <em>understanding</em> of what I was building.</p>
<p>This may seem obvious, that there can be wisdom in old material. But for my past self, I just wanted to learn things once. I just wanted to know, so I could do, and move on. And if we&rsquo;re all standing on the shoulders of giants, wouldn&rsquo;t that wisdom get passed to me in the new material anyway?</p>
<hr>
<h3 id="what-it-means-to-understand">What it means to understand.</h3>
<p>My aversion to reading older material came from my impatience and desire to just <em>know</em>. Just like how I didn&rsquo;t care to know <em>why</em> the derivative of <code>cos(x)</code> was <code>-sin(x)</code>, I just wanted to know the best mobile architecture for the type of app I&rsquo;m making. Or the best database to use. Or the best <em>insert solution here</em> for <em>insert current problem here</em>. If someone had made the mistake of giving me a leadership position, if I didn&rsquo;t arrogantly assume I already knew what I was doing, I would buy a brand new bestselling book on that topic. Certainly, the author had read the last bestseller, who&rsquo;s author had read the last bestseller, and so on. And through that magical chain, all of the knowledge of the past would be bestowed upon me, who is certainly smart enough to put it to effective use.</p>
<p>But I now finally understand why simply knowing is insufficient. Because its simply <em>impossible</em> to ever understand and truly grasp complex topics from one perspective.</p>
<p>Now, if I was in the Matrix and could be plugged directly into that last authors brain, maybe then one perspective would be sufficient. But we don&rsquo;t live in the Matrix, and as Marco Giancotti aptly paints with that example, <a href="https://aethermug.com/posts/language-is-a-bottleneck-for-thought">language is a bottleneck for thought</a>. While visual mediums can communicate be of magnitude more (a picture is worth a thousand words after all), as of now, we still have no way to communicate the exact intricacies of our mental models of the world to others. Through trying to start writing blog posts, I&rsquo;ve learned just how futile that can feel.</p>
<p>I felt like my world opened up and I finally understood software design after watching Rich Hickey&rsquo;s <a href="/blog/learning/simple_made_easy">Simple Made Easy</a>, but then I watched his <a href="/blog/learning/simplicity_matters">Simplicity Matters</a>, basically the same talk given later, and was surprised how much more I learned. Then I went back and watched the original again, and realized there was so much more I missed.</p>
<p>Listening to Ron Westrum talk about generative organizations on <a href="/blog/learning/idealcast">The Idealcast</a>, again I felt like my world opened up, and I finally understood what made some organizations great (and why work in a bureaucratic organization could feel so <a href="https://en.wikipedia.org/wiki/Sisyphus">&lsquo;Sisyphusian&rsquo;</a>).  But then, I listened to Elisabeth Hendrickson and Steven Spear&rsquo;s first appearances on the show, and not only did it give me a deeper understanding, but it affirmed and built on so much of what Ron Westrum had described in his episodes.</p>
<p>And all the sudden, just like those high ranking officers we all wanted to emulate, I found my bookshelf full of books.</p>
<p>It was when I started reading the classic <a href="/blog/learning/the_mythical_man_month"><em>The Mythical-Man Month</em></a> that the difference between knowing and understanding really clicked. I would have never considered reading this book in the past, with it being released all the way back in 1975. I mean c&rsquo;mon, even the way software was developed in the 90s seemed like a nightmare (git was released in <em>2005!</em>), what could this guy know?</p>
<p>But when I was reading it, I found myself constantly making connections to what I had learned previously from Rich Hickey and the Idealcast. Not only was I reading things that affirmed those lessons, but it was reading things that at first seemed to go against my model of the world that made me think the hardest and taught me the most. Things that made me <em>challenge</em> my understanding of the world. And at the end, that understanding only became sharper.</p>
<p>At the end of the day, while it might feel like we think in words, our brains are enormous neural networks with billions of lossy nodes. Even the most prolific thinkers and writers in human history couldn&rsquo;t possibly communicate the complete and deep understanding that they&rsquo;ve built up through <em>any</em> medium. No matter how many times I listen to everything Rich Hickey has ever said, despite his best efforts, I will never see and understand the world the way he does.</p>
<p>Only through our own constant learning and experience can we hope to build up our own, unique, but just as deep, understanding. As long as we are constantly receiving new inputs, whether through experience, classes, lectures, keynotes, blogs, or the books on our cool bookshelves we may have originally bought to make us look smart, we can train our neural networks to have as rich and thorough of an understanding as the leaders we admire and try to emulate.</p>
<p>And for all the impatient knowers out there who just want to get stuff done, take it from one of your own. To master a complex topic like software, and to really do it right, you need to learn how to <em>understand</em>, or you&rsquo;ll never become that expert who just gets stuff done. After all,</p>
<blockquote>
<p>Beginners Reason, Experts Recognize.</p>
<p>&mdash; <a href="/blog/learning/ten_things_about_learning/">10 Things Software Developers Should Learn about Learning</a></p>
</blockquote>
<p>And that&rsquo;s why those officers have all those books.</p>
<hr>
<h3 id="is-there-still-room-for-knowing">Is there still room for knowing?</h3>
<p>Yes, that was not rhetorical. Before we can understand something, we need to know as much as possible. I only made those deep connections reading Mythical Man-Month because I had remembered what Rich Hickey, Elisabeth Hendrickson, and Steven Spear had said. It was those connections between the different perspectives I knew that lead to understanding. I think the general &rsquo;three pillars&rsquo; model of language learning I applied while I learned Japanese in college applies here:</p>
<ol>
<li>Learn the words, so you know what the they&rsquo;re saying.</li>
<li>Learn the grammar, so you understand how those words go together.</li>
<li>Engage with the language as much as possible.</li>
</ol>
<p>I needed to know the words and the grammar, so I could engage with the language and build those connections of deep understanding.</p>
<p>But we really need to be conscious of what we&rsquo;re doing, and why we&rsquo;re doing it. We don&rsquo;t want to waste our time trying to apply an understanding strategy on things we should just know. Like with Japanese words: there was no getting around it, I needed to memorize the words. I needed to just know them, along with the grammar rules, so when I heard a sentence, I could make the connections and understand the sentence.</p>
<p>This is a mistake I see my current organization making. Our product is a Goliath of an accounting program without any cohesive documentation (even a lot of the <em>source code</em> is hidden from most devs). Instead, they encourage people build a deep understanding of <em>where</em> the code is or <em>where</em> a fix should be to align with the current system. This may sound confusing, but for various reasons (configuration code in a relational SQL database, classes have cryptic 5-8 letter code names, inter-class calls done through opaque messages, etc.), even finding where code is can be difficult. Basically, to make any changes, whether adding something or fixing a bug, the procedure is to go to that part of the system in the GUI and &lsquo;figure out&rsquo; where to make the changes.</p>
<p>And so it really does take a decade plus to build a deep understanding of how this system works. I&rsquo;ve met people who&rsquo;ve done it, its as impressive as it is tragic. Specific system configuration sits squarely on the <em>know</em> side of the fence, and the ease of access to that information needs to be highly optimized for. What is on the other side of the fence is <em>understanding</em> how different system architectures and configurations are better for certain use cases, and the emerging properties they will have when deployed at scale. That takes seeing and experiencing many different configurations before that understanding will ever be built up. Unfortunately, most members of my organization have spent their entire career with this system, and therefore struggle to even imagine any alternatives.</p>
<p>I started my <a href="/blog/learning/">learning collection</a> at the end of last year, to collect all the information I wanted to learn and be able to reference, so I could understand the complex topic of software. On top of my folder for software engineering, I now have folders for, leadership, languages, writing, music, and life. Only recently have I realized the true power in that has been how it optimized the speed of knowing, so I could finally build deep understandings of complex topics.</p>
<hr>
<h3 id="to-summarize">To Summarize:</h3>
<ul>
<li>It is impossible to understand a complex topic from a single source, due to the bottlenecks inherit in any medium of communication. So to understand complex topics, we need to be constantly learning and taking in as much input as possible to build up our internal neural networks and mental models of the world. There&rsquo;s no way around that.</li>
<li>We need to be conscious of what needs deep understanding to be effective at, and what should just be known. Then, we need to optimize for quick and easy access to that which should be known.</li>
</ul>
]]></content:encoded>
    </item>
  </channel>
</rss>
